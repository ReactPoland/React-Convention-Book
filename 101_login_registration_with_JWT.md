### Full-stack login and registration for our publishing app

<!-- TODO: DESCRIBE DIFFERENCE BETWEEN: The oAuth2, OpenID Connect and JSON Web Tokens (JWT) (if not enough page's count) -->


JWT is a security tokens format which is relatively new, but works very well. It's an open standard (RFC 7519) that improves oAuth2 and OpenID Connect in problem of passing claims between parties in web application environment.

More in practise the flow is as follwoing:
1) the server assigns an encoded JSON object
2) after client's knows it, then it sends that encoded token with every request to the server
3) based on that token, the server knows who is sending a request

It's worth to visit the http://jwt.io/ website and play with it because you can play with it even before you will start working with them:

![screenshot http://jwt.io/](http://test.przeorski.pl/book/101_jwt_io.png)

After successful login, the JWT's solution provides an object to our front-end application that tell's us about current's user authorization:

```
{"iss":"PublishginAppIssuer","name":"John Doe","admin":true}
```

The iss is an issuer property - in our case it will be our publishing app's backend application. Name of logged user is obvious - John Doe has logged in successfully. The admin property just is saying that an identified user (logged into our backend's app with correct login and password) is an admin ("admin": true flag). You will learn how to use it in that chapter.

Beside what has been said in the above's example, the JWT's response contains also information about subject/claims, signed SHA256's generated token and an expiration date. The important rule here is that you must be sure about the issuer of your token because then you need to trust to the content's provided alongside in the response. It may sounds complicated, but ***it is very simple*** in real life applications.

The important thing is that you ***need*** to keep protected the token generated by JWT - this security's topic will be elaborated later.


The flow is as following:
1) Our client's publishing app request a token from our express' server
2) The publishing backed app's issues a token to the front-end redux's app
3) And after that, each time we fetch data from backend then we check if a user has access to a requested resources on the backend - ***the resource consumes the token***.

In our case the resource is a falcor-router's routes which has close relationship with the backend, but this may work as well in more distributed platforms.

Remember that the JWT tokens are similar to private's keys - you must keep them secure!


### Structure of JWT token

1) The header has information that are required on the backend for recognizing what cryptographic operation to do based on that information (metadata, what algorithms & keys are used)

```
{
	"typ": "JWT",
	"alg": "HS256"
}
```

In general, that part is done 100% out of the box for us, so we don't have to care too much about headers while implementing it.


2) The second part are claims provided in the JSON format, as for example:

a) Issuer - so we know who has issued the token
b) Audience - so we know that this token has to be consumed by our application
c) Issue's date - when the token has been created
d) Expiration's date - when the token is expiring so we have to generate a new one
e) Subject - so an app can know which part of the app can use the token (useful in bigger application)

Besides the claims provided above, we can create custom one that are specific definied by the app's creator.

```
{
"iss": "http://theIssuerAddress",
"exp": "1450819372",
"aud": "http://myAppAddress",
"sub": "publishingApp",
"scope": ["read"]
}
```


TODO - review above.



PLAN PISANIA:
0) dodanie kolekcji users w bazie mongodb
1) stworzenie route'a do logowania usera
2) dodanie formularza na front'cie


### New MongoDB's users collection

We need create a users collection in our database. The users will have privilages to:
1) Add new articles in our publishing application
2) Edit existing articles in our publishing application
3) Delete articles in our publishing application.


First step is that we need to create a collection.

You can do it from GUI in Robomongo (introduced at the beginning of the book), but we here will use the command line.

First of all we need to create a file called initPubUsers.js with the content as following:
```
[
  {
    "username" : "admin",
    "password" : "c5a0df4e293953d6048e78bd9849ec0ddce811f0b29f72564714e474615a7852",
    "firstName" : "Kamil",
    "lastName" : "Przeorski",
    "email" : "kamil@mobilewebpro.pl",
    "role" : "admin",
    "verified" : false,
    "imageUrl" : "http://lorempixel.com/100/100/people/"
  }
]
```

##### Explanation:
The SHA256 string c5a0df4e293953d6048e78bd9849ec0ddce811f0b29f72564714e474615a7852 is a equilavent of a password 123456 with a salt's string equalt to "pubApp".

If you want to generate this salted password hash, then go to:
http://www.xorbin.com/tools/sha256-hash-calculator

and type ***123456pubApp*** on their website so you will get as following:
![sha256 salted password online](http://test.przeorski.pl/book/102_salted_password_sha256.png)










