### Full-stack login and registration for our publishing app

<!-- TODO: DESCRIBE DIFFERENCE BETWEEN: The oAuth2, OpenID Connect and JSON Web Tokens (JWT) (if not enough page's count) -->


JWT is a security tokens format which is relatively new, but works very well. It's an open standard (RFC 7519) that improves oAuth2 and OpenID Connect in problem of passing claims between parties in web application environment.

More in practise the flow is as follwoing:
1) the server assigns an encoded JSON object
2) after client's knows it, then it sends that encoded token with every request to the server
3) based on that token, the server knows who is sending a request

It's worth to visit the http://jwt.io/ website and play with it because you can play with it even before you will start working with them:

![screenshot http://jwt.io/](http://test.przeorski.pl/book/101_jwt_io.png)

After successful login, the JWT's solution provides an object to our front-end application that tell's us about current's user authorization:

```
{"iss":"PublishginAppIssuer","name":"John Doe","admin":true}
```

The iss is an issuer property - in our case it will be our publishing app's backend application. Name of logged user is obvious - John Doe has logged in successfully. The admin property just is saying that an identified user (logged into our backend's app with correct login and password) is an admin ("admin": true flag). You will learn how to use it in that chapter.

Beside what has been said in the above's example, the JWT's response contains also information about subject/claims, signed SHA256's generated token and an expiration date. The important rule here is that you must be sure about the issuer of your token because then you need to trust to the content's provided alongside in the response. It may sounds complicated, but ***it is very simple*** in real life applications.

The important thing is that you ***need*** to keep protected the token generated by JWT - this security's topic will be elaborated later.


The flow is as following:
1) Our client's publishing app request a token from our express' server
2) The publishing backed app's issues a token to the front-end redux's app
3) And after that, each time we fetch data from backend then we check if a user has access to a requested resources on the backend - ***the resource consumes the token***.

In our case the resource is a falcor-router's routes which has close relationship with the backend, but this may work as well in more distributed platforms.

Remember that the JWT tokens are similar to private's keys - you must keep them secure!


### Structure of JWT token

1) The header has information that are required on the backend for recognizing what cryptographic operation to do based on that information (metadata, what algorithms & keys are used)

```
{
	"typ": "JWT",
	"alg": "HS256"
}
```

In general, that part is done 100% out of the box for us, so we don't have to care too much about headers while implementing it.


2) The second part are claims provided in the JSON format, as for example:

a) Issuer - so we know who has issued the token
b) Audience - so we know that this token has to be consumed by our application
c) Issue's date - when the token has been created
d) Expiration's date - when the token is expiring so we have to generate a new one
e) Subject - so an app can know which part of the app can use the token (useful in bigger application)

Besides the claims provided above, we can create custom one that are specific definied by the app's creator.

```
{
"iss": "http://theIssuerAddress",
"exp": "1450819372",
"aud": "http://myAppAddress",
"sub": "publishingApp",
"scope": ["read"]
}
```


TODO - review above.



PLAN PISANIA:
0) dodanie kolekcji users w bazie mongodb
1) stworzenie route'a do logowania usera
2) dodanie formularza na front'cie


### New MongoDB's users collection

We need create a users collection in our database. The users will have privilages to:
1) Add new articles in our publishing application
2) Edit existing articles in our publishing application
3) Delete articles in our publishing application.


First step is that we need to create a collection.

You can do it from GUI in Robomongo (introduced at the beginning of the book), but we here will use the command line.

First of all we need to create a file called initPubUsers.js:
```
$ [[you are in the root directory of your project]]
$ touch initPubUsers.js
```

then add the content following content to the initPubUsers.js:
```
[
  {
    "username" : "admin",
    "password" : "c5a0df4e293953d6048e78bd9849ec0ddce811f0b29f72564714e474615a7852",
    "firstName" : "Kamil",
    "lastName" : "Przeorski",
    "email" : "kamil@mobilewebpro.pl",
    "role" : "admin",
    "verified" : false,
    "imageUrl" : "http://lorempixel.com/100/100/people/"
  }
]
```

##### Explanation:
The SHA256 string c5a0df4e293953d6048e78bd9849ec0ddce811f0b29f72564714e474615a7852 is a equilavent of a password 123456 with a salt's string equalt to "pubApp".

If you want to generate this salted password hash yourself, then go to:
http://www.xorbin.com/tools/sha256-hash-calculator

and type ***123456pubApp*** on their website so you will get as following:
![sha256 salted password online](http://test.przeorski.pl/book/102_salted_password_sha256.png)


These steps are required only on the beginning, later we need to program a registration form that is salting the password for our own.


##### Importing the initPubUsers.js file into MongoDB
After we have the correct content in our initPubUsers.js then we can run a command line as following in order to import that new pubUsers collection to our database:
```
mongoimport --db local --collection pubUsers --jsonArray initPubUsers.js --host=127.0.0.1
```

and you will get the same terminal's output as we were importing the article in the first chapter similar to this:
```
2009-04-03T11:36:00.566+0200  connected to: 127.0.0.1
2009-04-03T11:36:00.569+0200  imported 1 document
```

#### Working on the login's falcor-route

Now we need to start working with the falcor-router in order to create a new endpoint that will use the jwt library to provide a unique tokens for the client-side app.

The first thing that we need to do is to provide a "secret" on the backend.

Let's create that secret's config file:
```
$ cd server
$ touch configSecret.js
```

Now we need to put a content of this secret:
```
export default {
  'secret': process.env.JWT_SECRET || 'devSecretGoesHere'
}
```
In future we will use enviroment variables on the production server, so this notation ***process.env.JWT_SECRET  || 'devSecretGoesHere'*** means that the enviroment variable of JWT_SECRET doesn't exsit then please use deafult secret's string ('devSecretGoesHere'). At this point we don't need any development enviroment variables.


#### Creating a falcor-router's login (backend)

In order to make our codebase more organized, instead of adding one more route to our ***server/routes.js*** file, we will make a new file called ***routesSession.js*** and in that file we will keep all endpoints related to the current logged user's session:

Make sure you are in the server dir:
```
$ cd server
```

then create a new file:
```
$ touch routesSession.js
```

And put this initial content into the ***routesSession.js*** file:

```
export default [
  { 
    route: ['login'] ,
    call: (callPath, args) => 
      {
        let { username, password } = args[0];

        let userStatementQuery = {
          $and: [
              { 'username': username },
              { 'password': password }
          ]
        }
      }
  }
];
```

#### Explanation how works the call routes:
Above we have created an initial call login route in the ***routesSession.js*** file. You can find that instead of using 'get' method, we are going to use a 'call' (***call: async (callPath, args) => ***). That is equivalent of POST for old RESTful approach. 

The difference between call and get method in falcor's routes is that we can provide arguments with ***args***. That allows us to get from the client-side the username and the password. 

The plan is that after we receive credentials with this:
```
let { username, password } = args[0];
```

then we will check them against our database with one user admin. A user will need to know that the real plaintext password is ***123456*** in order to get a correct login jwt token.

We also have prepared in this step a ***userStatementQuery*** - this will be used later when querying a database:
```
let userStatementQuery = {
  $and: [
      { 'username': username },
      { 'password': password }
  ]
}
```

#### Separating the DB configs - configMongoose.js

We need to separate DB configs from routes.js:
```
$ touch configMongoose.js
```

and it's new content:
```
import mongoose from 'mongoose';

const conf = {
  hostname: process.env.MONGO_HOSTNAME || 'localhost',
  port: process.env.MONGO_PORT || 27017,
  env: process.env.MONGO_ENV || 'local',
};

mongoose.connect(`mongodb://${conf.hostname}:${conf.port}/${conf.env}`);

var articleSchema = {
  articleTitle:String,
  articleContent:String
}

var Article = mongoose.model('Article', articleSchema, 'articles');

export default {
  Article
}
```

#### Explanation:
Above we have introduced new env variables as following: MONGO_HOSTNAME, MONGO_PORT, MONGO_ENV. We will use them when preparing a production enviroment. 

The ***`mongodb://${conf.hostname}:${conf.port}/${conf.env}`*** is using templating feature available since EcmaScript6.

Rest of the configMongoose.js config shall be known for you as we introduced it in the chapter 1.

#### Improving the routes.js file
After we have two new files: configMongoose.js and routesSession.js then we have to improve our ***server/routes.js*** file in order to make everything cooperate together.


First step, delete from routes.js the following code:
```
import mongoose from 'mongoose';

mongoose.connect('mongodb://localhost/local');

var articleSchema = {
  articleTitle:String,
  articleContent:String
}

var Article = mongoose.model('Article', articleSchema, 'articles');
```

and replace it with new:
```
import { Article } from './configMongoose';
import sessionRoutes from './routesSession';
```

also we need to spread the sessionRoutes into our current PublishingAppRoutes as following:
```
let PublishingAppRoutes = [
    ...sessionRoutes,
  {
  route: 'articles.length',
```
At the beginning of PublishingAppRoutes you need to spread ***...sessionRoutes,*** routes, so the login route will be available to use accross the Falcor's routes.

#### Explanation
We got rid off old code that was helping us to run the first mongoose query that were fetching the articles, we moved everyting to ***configMongoose*** so then we can use it in different files around our project. We have also imported the ***sessionRoutes*** and later spreaded them with the ***...*** spread operation into the array called ***PublishingAppRoutes***.

#### Double-check if app works, before implementing JWT
At this point, when doing ***npm start*** the app shall be working and showing the list of articles:
```
Our publishing app

Lorem ipsum - article one

Here goes the content of the article

Lorem ipsum - article two

Sky is the limit, the content goes here.
```

when running with ***npm start*** you shall get the following information that everything works correctly:
```
Hash: eeeb09711c820a7978d5
Version: webpack 1.12.14
Time: 2609ms
 Asset    Size  Chunks             Chunk Names
app.js  1.9 MB       0  [emitted]  main
   [0] multi main 40 bytes {0} [built]
    + 634 hidden modules
Started on port 3000
```

#### Creating a Mongoose users' model

In the file ***configMongoose.js*** we need to create and export a User model. Please add following code to that file:
```
var userSchema = {
  "username" : String,
  "password" : String,
  "firstName" : String,
  "lastName" : String,
  "email" : String,
  "role" : String,
  "verified" : Boolean,
  "imageUrl" : String
}

var User = mongoose.model('User', userSchema, 'pubUsers');


export default {
  Article,
  User
}
```
#### Explanation
The ***userSchema*** describes our user's json model, next the ***User*** is our mongoose's model that is pointing to the 'pubUsers' collection in our MongoDB. At the end, we are exporting the ***User*** model by adding it to the ***export default***'s object. 


#### Implementing JWT in the routesSession.js file

First step is to export our User's model into the routesSession's scope by adding at the top of that file an import statement:
```
import { User } from './configMongoose';
````

Installing the jsonwebtoken & crypto (for SHA256):
```
$ npm i --save jsonwebtoken crypto
```

After you have installed jsonwebtoken, the we need to import it to the ***routesSession.js***:
```
import jwt from 'jsonwebtoken';
import crypto from 'crypto';
import jwtSecret from './configSecret';
```

After you have imported everything in the routesSession, then let's
continue on working with the ***route: ['login']***.

Below you need to improve the userStatementQuery, so it will have the saltedPassword instead of plain text:
```
let saltedPassword = password+"pubApp"; // pubApp is our salt string
let saltedPassHash = crypto.createHash('sha256').update(saltedPassword).digest('hex');
let userStatementQuery = {
  $and: [
      { 'username': username },
      { 'password': saltedPassHash }
  ]
}
``` 
... so instead of plain text, then we will query a salted SHA256 password.

... under this ***userStatementQuery*** please return a Promise, with following details:
```
        return User.find(userStatementQuery, function(err, user) {
          if (err) throw err;
        }).then((result) => {
          if(result.length) {
            return null; // SUCCESSFUL LOGIN mocked now (will implement next)
          } else {
            // INVALID LOGIN
            return [
              {
                path: ['login', 'token'], 
                value: "INVALID"
              },
              {
                path: ['login', 'error'], 
                value: "NO USER FOUND, incorrect login information" 
              }
            ];
          }
          return result;
        });
```

#### Explanation
The ***User.find*** is a Promise that comes from the Mongoose's user's model (that we have created in configMongoose.js) - this is a standard method. Then as a first argument we provide ***userStatementQuery*** which is that filter's object with username and password in it (****{ username, password } = args[0];***). 

Next we provide a function that is a callback, when the query is done (***function(err, user) {***). We count amount of results with ***if(result.length) {***. 

In case if result.length === 0 then we have mocked return statement, then we are getting the else code running with following return:
```
            return [
              {
                path: ['login', 'token'], 
                value: "INVALID"
              },
              {
                path: ['login', 'error'], 
                value: "NO USER FOUND, incorrect login information" 
              }
            ];
```

As you will learn later, we will ask for that token's path on the front-end (later in this chapter) ***['login', 'token']***. In this case we haven't found the correct username and the password provided so we return ***"INVALID"*** string, instead of a JWT token. The path ***['login', 'error']*** is describing the error's type in more details so that message can be shown to a user that has provided invalid login's credentials.


#### Successful login on falcor-route
We need to improve successful login path. We have a case for handling an invalid login, we need to make a case that will handle a successful login, so please replace this code:
```
return null; // SUCCESSFUL LOGIN mocked now (will implement next)
```

with this code that is returning successful login's details:
```
let role = result[0].role;
let userDetailsToHash = username+role;
let token = jwt.sign(userDetailsToHash, jwtSecret, { expiresIn: '1h' });
return [
  {
    path: ['login', 'token'],
    value: token
  },
  {
    path: ['login', 'username'],
    value: username
  },
  {
    path: ['login', 'role'],
    value: role
  },
  {
    path: ['login', 'error'],
    value: false
  }
];
```

#### Explanation:
As you can see, the only thing that we fetch from DB right now is the role value === ***result[0].role***. We need add this to hash, because we don't want our app to be vulnerable so a normal user can get an admin role with some hacking. The value of the ***token*** is calculated based on ***userDetailsToHash = username+role*** - that's enough for now. We also added as a third argument in the jwt.sign an information about how long the token shall be valid (***{ expiresIn: '1h' }***).

After we are fine here the only thing that needs to be done on the backend is returning the paths with values:
1) The login token with: ['login', 'token']
2) The username with ['login', 'username']
3) The logged user's role with: ['login', 'role']
4) ... and an information that there were no errors' at all with: ['login', 'error']

The next step is to use this route on the Front-end.

Please run the app and then if everything is working for you, and after it works for you then let's to start the front-end codings' fun right now!



### Front-end side and Falcor

Let's create a new route for login in our redux application. In order to do that, we need to introduce the ***react-router***:
```
$ npm i --save react-router@2.0.1 redux-simple-router@2.0.4
```

After we have installed them, we need to add routes in the src:
```
$ cd src
$ mkdir routes
$ touch index.js
```

then make the content of this index.js file as following:
```
import React                        from 'react';
import { Route, IndexRoute }        from 'react-router';

/* wrappers */
import PublishingApp                   from 'layouts/PublishingApp';

/* authorization views */
import LoginView                    from 'views/account/LoginView';

export default (
  <Route component={CoreLayout} path='/'>
    <IndexRoute component={HomeView} name='home' />

    /* authorization related routes */
    <Route component={LoginView}  path='/login' name='login' />
  </Route>
);
```

At this points we are missing one component for our app called CoreLayout.

#### CoreLayout
The CoreLayout is the a for our whole application.

Create it by doing as following:
```
cd ../layouts/
touch CoreLayout.js
```

... and then populate it with the following content:
```
import React from 'react';

class CoreLayout extends React.Component {
  static propTypes = {
    children : React.PropTypes.element
  }

  constructor(props) {
    super(props);

  }

  render () {
    return (
      <div>
        <span>[In future there will be a header]</span>
          <br/>
          {this.props.children}
      </div>
    );
  }
}

export default CoreLayout;
```
As you probably know, the all content of a current route will go into the ***{this.props.children}***'s target (that is basic's React.JS concept you must to know beforehand).










